import hashlib,struct,zlib,os,glob,io


key = 'a9231213e7231' # 这里换成你的key


repeatLen = 0x83 # 默认都是0x83


N = 624


M = 397


MATRIX_A = 0x9908b0df


UPPER_MASK = 0x80000000


LOWER_MASK = 0x7fffffff


mt = [1]*N


mti = N+1


def init_genrand(s):


global mti


mt[0] = s&0xffffffff


for i in range(1,N):


mt[i] = (1812433253*(mt[i-1]^(mt[i-1]>>30))+i);


mt[i] &= 0xffffffff


mti = N


def init_by_array(init_key,key_length):


init_genrand(19650218)


i=1


j=0


if N>key_length:


k = N


else:


k = key_length


for x in range(k):


mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1664525))+ init_key[j] + j


mt[i] &=0xffffffff


i+=1


j+=1


if i>=N:


mt[0] = mt[N-1]


i = 1


if j>=key_length:


j=0


k = N-1


while k!=0:


k-=1


mt[i] = (mt[i] ^ ((mt[i-1] ^ (mt[i-1] >> 30)) * 1566083941))- i


mt[i] &= 0xffffffff


i += 1


if i>=N:


mt[0] = mt[N-1]


i = 1


mt[0] = 0x80000000


def genrand_int32():


mag01 = [0x0,MATRIX_A]


global mti


if mti >= N:


if mti == N+1:


init_genrand(5489)


for kk in range(N-M):


y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK)


mt[kk] = mt[kk+M] ^ (y >> 1) ^ mag01[y & 0x1]


for kk in range(N-M,N-1):


y = (mt[kk]&UPPER_MASK)|(mt[kk+1]&LOWER_MASK)


mt[kk] = mt[kk+(M-N)] ^ (y >> 1) ^ mag01[y & 0x1]


y = (mt[N-1]&UPPER_MASK)|(mt[0]&LOWER_MASK)


mt[N-1] = mt[M-1] ^ (y >> 1) ^ mag01[y & 0x1]


mti = 0


y = mt[mti]


mti += 1


y ^= (y>>11)


y ^= (y & 0xff3a58ad) << 7


y &= 0xffffffff


y ^= (y & 0xffffdf8c) <<15


y &= 0xffffffff


y ^= (y >> 18)


return y




# 关键点
# 把所有的m文件丢到src目录下，第一部要获取解密的m
files = glob.iglob('src\\*.m')
# 创建dec文件夹
if os.path.exists('dec\\') == False:
os.makedirs('dec\\')


for src in files:
dirname = os.path.dirname(src)
filename = os.path.basename(src)


String = key+filename
#print(String)



seed = hashlib.md5(String.encode('ascii')).digest()


num =[0]*4


for i in range(4):


tmp = seed[i*4:(i+1)*4]


num[i] = struct.unpack('<I',tmp)[0]


init_by_array(num,4)


repeattime = 0


if repeatLen%4 == 0:


repeattime = repeatLen //4


else:


repeattime = repeatLen //4 +1


array = [b'\x00']*(repeattime*4)


k=0


for i in range(repeattime):


arraypack = genrand_int32()


arraytmp = struct.pack('<I',arraypack)


for x in range(4):


array[k] = arraytmp[x]


k += 1


f = open(dirname+'\\'+filename,'rb')


basename,extname = os.path.splitext(filename)


fw = open('dec\\'+basename,'wb')


f.seek(8)


print(filename)


bytebuf = f.read()


k = 0


newbuf = io.BytesIO()


#print(hex(array[k]))


for chr in bytebuf:


x = chr ^ array[k]


newbuf.write(struct.pack('B',x))


k = (k+1) % repeatLen



try:
hehe = zlib.decompress(newbuf.getvalue())
#print('OK')
except:
hehe = newbuf.getvalue()
print('NO')




fw.write(hehe)


fw.flush()


fw.close()


f.close()